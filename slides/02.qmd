---
engine: knitr
title: Names and values
---

## Learning objectives

- Distinguish between an *object* and its *name*.
- Identify when data are *copied* versus *modified*.
- Trace and identify the memory used by R.

The lobstr package will help us through the chapter

```{r}
library(lobstr)
```


## Syntactic names are easier to create and work with than non-syntactic names


- Syntactic names: `my_variable`, `x`, `cpp11`, `.by`. Don't use those in `?Reserved`.

- Non-syntactic names need to be surrounded in backticks. 

## The name `a` is bound to the values `c(1, 2, 3)`

```{r}
a <- c(1, 2, 3)
a
obj_addr(a)
```

## Many names can be bound to the same values

```{r}
b <- a
obj_addr(a)
obj_addr(b)
```

## If shared values are modified, the object is copied automatically

```{r}
b[[1]] <- 5
obj_addr(a)
obj_addr(b)
```

## Though the values for names seem the same, the values in memory are distinct

```{r}
a <- 1:10
b <- a
c <- 1:10

obj_addr(a)
obj_addr(b)
obj_addr(c)
```

## Unlike the values `1:10`, functions and environments share the same memory address

```{r}
obj_addr(mean)
obj_addr(base::mean)

e <- new.env()
obj_addr(e)
e[['a']] <- 1
obj_addr(e)
```

## Use `tracemem` to validate if values are copied or modified

```{r}
x <- runif(10)
tracemem(x)
y <- x
x[[1]] <- 10
```

## `tracemem` shows that copies are minimized when using internal C code like lists

```{r}
y <- as.list(x)
tracemem(y)
medians <- vapply(x, median, numeric(1))
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}

as.list.default
```

## The environment in functions also copy values

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
z <- f(x) # No change in value

obj_addr(x)
obj_addr(z)
```

![](images/02-trace.png)

## Using `ref()` shows the memory address of a list and its *elements* unlike `obj_addr()`

```{r}
l1 <- list(1, 2, 3)
obj_addr(l1)
l2 <- l1
l2[[3]] <- 4
ref(l1, l2)
```

![](images/02-l-modify-2.png){width=50%}

## Since dataframes are lists of (column) vectors, mutating a column modifies only that column

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d2[, 2] <- d2[, 2] * 2
ref(d1, d2)
```

## Since dataframes are lists of (column) vectors, mutating a row modifies the whole dataframe value

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d2[1, ] <- d2[1, ] * 2
ref(d1, d2)
```

## Characters are unlike vaslues like `1:10` since these objects are "reused" from a global string pool

```{r}
x <- 1:4
ref(x)
x <- c("a", "a", "abc", "d")
ref(x,character = TRUE)
```

![](images/02-character-2.png)

## How much memory can be measured using `lobstr::obj_size` compared with just traced using `lobstr::obj_addr`

```{r}
banana <- "bananas bananas bananas"
obj_addr(banana)
obj_size(banana)
```

## Alternative Representation or ALTREPs represent vector values efficiently

```{r}
x <- 1:10
obj_size(x)
y <- 1:10000
obj_size(y)
```

## We can measure memory for dynamically created values using `benc::mark()`

```{r}
med <- function(d, medians) {
  for (i in seq_along(medians)) {
    d[[i]] <- d[[i]] - medians[[i]]
  }
}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))
y <- as.list(x)

bench::mark(
  "data.frame" = med(x, medians),
  "list" = med(y, medians)
)
```

## Though not needed to call explicitly, deleted object's can be given to the OS using the garbage collector `gc()`

```{r}
gc()
```