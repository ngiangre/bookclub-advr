---
engine: knitr
title: Names and values
---

## Learning objectives

- Distinguish between an *object* and its *name*.
- Identify when data are *copied* versus *modified*.
- Trace and identify the memory used by R.

The `{lobstr}` package will help us throughout the chapter

```{r}
library(lobstr)
```


## Syntactic names are easier to create and work with than non-syntactic names


- Syntactic names: `my_variable`, `x`, `cpp11`, `.by`.
  - Can't use names in `?Reserved`

- Non-syntactic names need to be surrounded in backticks. 

## Names are *bound to* values with `<-`

```{r}
a <- c(1, 2, 3)
a
obj_addr(a)
```

## Many names can be bound to the same values

```{r}
b <- a
obj_addr(a)
obj_addr(b)
```

## If shared values are modified, the object is copied to a new address

```{r}
b[[1]] <- 5
obj_addr(a)
obj_addr(b)
```

## Memory addresses can differ even if objects seem the same

```{r}
a <- 1:10
b <- a
c <- 1:10

obj_addr(a)
obj_addr(b)
obj_addr(c)
```

## Functions have a single address regardless of how they're referenced

```{r}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(get("mean"))
```

## Unlike most objects, environments keep the same memory address on modify

```{r}
d <- new.env()
obj_addr(d)
e <- d
e[['a']] <- 1
obj_addr(e)
obj_addr(d)
d[['a']]
```

## Use `tracemem` to validate if values are copied or modified

```{r}
#| eval: false
x <- runif(10)
tracemem(x)
#> [1] "<000001F4185B4B08>"
y <- x
x[[1]] <- 10
#> tracemem[0x000001f4185b4b08 -> 0x000001f4185b4218]:
untracemem(x)
```

## `tracemem` shows internal C code minimizes copying

```{r}
#| eval: false
y <- as.list(x)
tracemem(y)
#> [1] "<000001AD67FDCD38>"
medians <- vapply(x, median, numeric(1))
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
#> tracemem[0x000001ad67fdcd38 -> 0x000001ad61982638]:
untracemem(y)
```

## A function's environment follows copy-on-modify rules

:::: {.columns}

::: {.column}
```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
z <- f(x) # No change in value

obj_addr(x)
obj_addr(z) # No address change 
```
:::

::: {.column}
![](images/02-trace.png)
:::

::::

::: notes
- Diagrams will be explained more in chapter 7.
- `a` points to same address as `x`.
- If `a` modified inside function, `z` would have new address.
:::


## `ref()` shows the memory address of a list and its *elements*

:::: {.columns}

::: {.column}
```{r}
l1 <- list(1, 2, 3)
obj_addr(l1)
l2 <- l1
l2[[3]] <- 4
ref(l1, l2)
```
:::

::: {.column}
![](images/02-l-modify-2.png){width=50%}
:::

::::

## Since dataframes are lists of (column) vectors, mutating a column modifies only that column

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d2[, 2] <- d2[, 2] * 2
ref(d1, d2)
```

## Since dataframes are lists of (column) vectors, mutating a row modifies the value

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d2[1, ] <- d2[1, ] * 2
ref(d1, d2)
```

::: notes
- Here "mutate" means "change", not `dplyr::mutate()`
:::

## Characters are unique due to the global string pool

:::: {.columns}

::: {.column}
```{r}
x <- 1:4
ref(x)
y <- 1:4
ref(y)
x <- c("a", "a", "b")
ref(x, character = TRUE)
y <- c("a")
ref(y, character = TRUE)
```
:::

::: {.column}
![](images/02-character-2.png)
:::

::::

::: notes
- "a" is always at the same address.
- Each member of character vector has its own address (kind of list-like).
:::

## Memory amount can also be measured, using `lobstr::obj_size`

```{r}
banana <- "bananas bananas bananas"
obj_addr(banana)
obj_size(banana)
```

## Alternative Representation or ALTREPs represent vector values efficiently

```{r}
x <- 1:10
obj_size(x)
y <- 1:10000
obj_size(y)
```

## We can measure memory & speed using `bench::mark()`

```{r}
med <- function(d, medians) {
  for (i in seq_along(medians)) {
    d[[i]] <- d[[i]] - medians[[i]]
  }
}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))
y <- as.list(x)

bench::mark(
  "data.frame" = med(x, medians),
  "list" = med(y, medians)
)[, c("min", "median", "mem_alloc")]
```

::: notes
- The thing to see: list version uses less RAM and is faster
:::

## The garbage collector `gc()` explicitly clears out unbound objects

```{r}
x <- 1:3
x <- 2:4 # "1:3" is orphaned
rm(x) # "2:4" is orphaned
gc()
lobstr::mem_used() # Wrapper around gc()
```

::: aside
`gc()` runs automatically, never *need* to call
:::

::: notes
- `mem_used()` multiplies Ncells "used" by either 28 (32-bit architecture) or 56 (64-bit architecture)., and Vcells "used" by 8, adds them, and converts to Mb.
:::