---
engine: knitr
title: Names and values
---

## Learning objectives

- Distinguish between an *object* and its *name*.
- Identify when data are *copied* versus *modified*.
- Trace the memory used by R.

The lobstr package will help us through the chapter

```{r, echo = TRUE}
library(lobstr)
```


## Quiz 1: Syntactic vs Non-syntactic names


- **Syntactic names:** contain alphanumeric digits, `.`, and  `_`.

- **Non-syntactic names:** 
  - Start with `_` or `0-9`. 
  - Workaround: surround in \`.

Also, can't use reserved words found at `?Reserved`. 

## Quiz 2. On which line does `a` get copied


```{r}
a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

> Not until `b` is modified, the third line

## Binding basics

- Create values like `1` and *bind* a name to them like `a`. Cannot bind values to names
- We can look at an object's address to keep track of the values independent of their names

```{r, echo = TRUE}
x <- c(1, 2, 3)
y <- x
x
obj_addr(x)
y
obj_addr(y)

y[2] <- 3

obj_addr(x)
obj_addr(y)
```


## More binding basics

```{r, echo = TRUE}
a <- 1:10
b <- a
c <- b
d <- 1:10

obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)
```

> `a` `b` and `c` are all names that refer to the first value `1:10`
> 
> `d` is a name that refers to the *second* value of `1:10`.

## Exercise

**1. Do the following all point to the same underlying function object? hint: `lobstr::obj_addr()`**

```{r, echo = TRUE}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(get("mean"))
obj_addr(evalq(mean))
obj_addr(match.fun("mean"))
```

> Yes!

## Copy-on-modify

```{r, echo = TRUE}
x <- c(1, 2, 3)
y <- x
obj_addr(x)
obj_addr(y)
```

- If you modify a value bound to multiple names, it is 'copy-on-modify'

```{r, echo = TRUE}
y[2] <- 3
obj_addr(x)
obj_addr(y)
```

## Excessive copying

We can use `tracemem()` to deduce copies empiracally.

```{r, echo = TRUE}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))

cat(tracemem(x), "\n")
for (i in 1:5) {
  x[[i]] <- x[[i]] - medians[[i]]
}
untracemem(x)
```

## Minimizing copies with objects using internal C code

```{r, echo = TRUE}
y <- as.list(x)
cat(tracemem(y), "\n")
#> <0x7f80c5c3de20>
  
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
```

> Can also use `ref(x)` to get the address of the value bound to a given name

## Environments are always modify-in-place

This property is sometimes described as reference semantics because when you modify an environment all existing bindings to that environment continue to have the same reference.

```{r, echo = TRUE}
e1 <- rlang::env(a = 1, b = 2, c = 3)
e2 <- e1
e1$c <- 4
e2$c
```

## Pop Quiz!

**What does this do?**

```{r, echo =  TRUE}
x <- list()
x[[1]] <- x
```

## Pop Quiz!

**Answer: Copy-on-modify**

```{r, echo =  TRUE}
x <- list()
x
obj_addr(x)
x[[1]] <- x
x
obj_addr(x)
```

## Functions

- Copying also applies within functions
- If you copy (but don't modify) `x` within `f()`, no copy is made

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
z <- f(x) # No change in value

obj_addr(x)
obj_addr(z)
```

![](images/02-trace.png)

## Lists

- A list overall, has it's own reference (id)
- List *elements* also each point to other values
- List doesn't store the value, it *stores a reference to the value*
- As of R 3.1.0, modifying lists creates a *shallow copy*
    - References (bindings) are copied, but *values are not*

```{r}
l1 <- list(1, 2, 3)
l2 <- l1
l2[[3]] <- 4
```

- We can use `ref()` to see how they compare
  - See how the list reference is different
  - But first two items in each list are the same

```{r}
ref(l1, l2)
```

![](images/02-l-modify-2.png){width=50%}

## Data Frames

- Data frames are lists of vectors
- So copying and modifying a column *only affects that column*
- **BUT** if you modify a *row*, every column must be copied

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d3 <- d1
```

Only the modified column changes
```{r}
d2[, 2] <- d2[, 2] * 2
ref(d1, d2)
```

All columns change
```{r}
d3[1, ] <- d3[1, ] * 3
ref(d1, d3)
```

## Character vectors

- R has a **global string pool**
- Elements of character vectors point to unique strings in the pool

```{r}
x <- c("a", "a", "abc", "d")
ref(x, character = TRUE)
```

![](images/02-character-2.png)

## Exercises

**1. Why is `tracemem(1:10)` not useful?**

> Because it tries to trace a value that is not bound to a name

## Exercises

**2. What is the relationships among these objects?**

```{r}
a <- 1:10      
b <- list(a, a)
c <- list(b, a, 1:10) # 
```

a <- obj 1    
b <- obj 1, obj 1    
c <- b(obj 1, obj 1), obj 1, 1:10    

```{r}
ref(c)
```

## Quiz

**1. How much memory does `y` occupy?**

```{r, echo = TRUE}
x <- runif(1e6)
lobstr::obj_size(x)
y <- list(x, x, x)
lobstr::obj_size(y)
```

> `object.size()` does not attribute memory allocation accurately. Here, it over-estimates the shared memory of the list wit its elements:

```{r, echo = TRUE}
object.size(y)
```


## Object Size

- Use `lobstr::obj_size()` 
- Lists may be smaller than expected because of referencing the same value
- Strings may be smaller than expected because of global string pool

```{r, echo = TRUE}
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

## Alternative Representation

- As of 3.5.0, the use of ALTREP represents vectors compactly
    - e.g., 1:1000 - not 10,000 values, just 1 and 1,000

## Exercises

**1. Why are the sizes so different?**

```{r}
y <- rep(list(runif(1e4)), 100)

object.size(y) # ~8000 kB
obj_size(y)    # ~80   kB
```

> From `?object.size()`: 
> 
> "This function merely provides a rough indication: it should be reasonably accurate for atomic vectors, but **does not detect if elements of a list are shared**, for example.

## Exercises

**2. Why is the size misleading?**

```{r}
obj_size(mean)
funs <- list(mean, sd, var)
obj_size(funs)
```

> Because they reference functions from base and stats, which are always available.
> Why bother looking at the size? What use is that?

## Exercises

**3. Predict the sizes**

```{r}
a <- runif(1e6) # 8 MB
obj_size(a)
```


```{r}
b <- list(a, a)
obj_size(b)
```

- There is one value ~8MB
- `a` and `b[[1]]` and `b[[2]]` all point to the same value.

```{r}
obj_size(a, b)
```


```{r}
b[[1]][[1]] <- 10
obj_size(b)     # 16 MB (two values, two element references)
obj_size(a, b)  # 16 MB (a & b[[2]] point to the same value)
```
- Now there are two values ~8MB each (16MB total)
- `a` and `b[[2]]` point to the same value (8MB)
- `b[[1]]` is new (8MB) because the first element (`b[[1]][[1]]`) has been changed

## Benchmark this (Exercise #2)

```{r, echo = TRUE}
med <- function(d, medians) {
  for (i in seq_along(medians)) {
    d[[i]] <- d[[i]] - medians[[i]]
  }
}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))
y <- as.list(x)

bench::mark(
  "data.frame" = med(x, medians),
  "list" = med(y, medians)
)

x <- data.frame(matrix(runif(5 * 1e4), ncol = 20))
medians <- vapply(x, median, numeric(1))
y <- as.list(x)

bench::mark(
  "data.frame" = med(x, medians),
  "list" = med(y, medians)
)
```

## Exercises

**1. What happens if you attempt to use tracemem() on an environment?**

```{r}
#| error: true
e1 <- rlang::env(a = 1, b = 2, c = 3)
tracemem(e1)
```

> Because environments always modified in place, there's no point in tracing them


## Unbinding and the garbage collector

- If you delete the 'name' bound to an object, the object still exists in memory
- R runs a "garbage collector" (GC) to remove unused objects when it needs more memory
- "Looking from the outside, it’s basically impossible to predict when the GC will run. In fact, you shouldn’t even try."
- If you want to know when it runs, use `gcinfo(TRUE)` to get a message printed
- You can force GC with `gc()` but you never need to use more memory *within* R
- Only reason to do so is to free memory for other system software, or to get the message printed about how much memory is being used

```{r}
gc()
mem_used()
```

## GC memory vs. Operating System memory

- These numbers will **not** be what your OS tells you because, 
  1. It includes objects created by R, but not R interpreter
  2. R and OS are lazy and don't reclaim/release memory until it's needed
  3. R counts memory from objects, but there are gaps due to those that are deleted -> 
  *memory fragmentation* [less memory actually available then you might think]
